options(bank:-2);

use * from common;
use rle;
use game;
use my;
use mem;

var data:int[256] options(address:0x6000);
var enemy:int[256] options(address:0x6100);
var data_buf:int[256] options(address:0x6200);
var enemy_num:int;

var buf_idx:int;
var buf:int[256] options(address:0x6500);
var pal:int[64];

var pallet:int[32];

var cur_area:int;

var tile_pal:int[64] options(address:0x6300);

const TYPE_WALL = 1 << 0;
const TYPE_FLOOR = 1 << 1;
const TYPE_SPIKE = 1 << 2;
const TYPE_EWALL = 1 << 3;
const TYPE_STOP = TYPE_WALL | TYPE_EWALL | TYPE_FLOOR;
const TYPE_LADDER = 1 << 4;
const TYPE_WATER = 1 << 5;

// 1 WALL  : 壁
// 2 FLOOR : 床( 上半分だけの壁 )
// 4 SPIKE : とげ
// 8 EWALL : 自分は通れるが、敵が通れない
// 1 LADDER: はしご
// 2
// 4
// 8
const TILE_TYPE:int[] =
	[   0,   0,   0,   0,   0,   0,   0,   0,
	    0,   1,   3,0x13,0x10,   0,   0,   0,
	    0,   1,   1,   0,   4,   4,   4,   4,
	 0x20,0x20,0x20,0x20,0x20,   1,   8,   1,

		// 中
		0,   1,   3,   0,   0,   0,0x13,0x10,
		4,   4,   4,   4,   4,   0,   0,   0,
		0,   0,   0,   0,   0,   0,   0,   0,
		1,   0,   1,   3,   1,   3,   0,   8,

		// 外
		1,   1,   1,   3,   0,   0,0x13,0x10,
		1,   1,   1,   0,   0,   0,   0,   0,
		0,   0,   0,   0,   0,   0,   0,   0,
		1,   0,   1,   3,   1,   3,   0,   0,

		// 西
		1,   1,   1,   3,   0,   0,0x13,0x10,
		1,   1,   1,   0,   0,   0,   0,   0,
		0,   0,   0,   0,   0,   0,   0,   0,
		1,   0,   1,   3,   1,   3,   0,   0,

		// 下
		1,   1,   1,   3,   0,   0,0x13,0x10,
		1,   1,   1,   0,   0,   0,   0,   0,
		0,   0,   0,   0,   0,   0,   0,   0,
		1,   0,   1,   3,   1,   3,   0,   0];

var tile_type:int[64] options( address:0x6340 );

private:

public function init():void
{
	cur_area = 0;
	buf_idx = 0;
	ppu.on_wait_vsync = ->void(){ buf_idx = 0; };
	fs.copy( tile_pal, fs.TILE_PAL_BASE+0 );
	fs.copy( &tile_pal[32], fs.TILE_PAL_BASE+1 );
	mem.copy( tile_type, TILE_TYPE, 64 );
}

public function cell(x:int, y:int):int
{
	return data[(y/16)*16 + x/16];
}

public function cell_type(x:int, y:int):int
{
	return tile_type[data[(y/16)*16 + x/16]];
}

function set_pal(x:int, y:int, _pal:int):int
{
	var pal_addr:int8 = (y/2)*8 + x/2;
	var pos = (((y%2)*2) | (x%2))*2;
	var mask:int = (0b00000011 << pos) ^ 0xff;
	pal[pal_addr] = (pal[pal_addr] & mask) | (_pal << pos);
	return pal_addr;
}

public function put2(x:int, y:int, n:int, pal:int):void
{
	data[y*16+x] = n;
	put(x,y,n,pal);
}

public function put(x:int, y:int, n:int, _pal:int):void
{
	var y16:int16 = y;
	var addr:int16 = 0x2000 + y16*64 + x*2;
	var ni = n * 4;
	buf[buf_idx+0] = ni;
	buf[buf_idx+1] = ni+2;
	buf[buf_idx+2] = ni+1;
	buf[buf_idx+3] = ni+3;
	ppu.put( addr, &buf[buf_idx], 2, 0 );
	ppu.put( addr+32, &buf[buf_idx+2], 2, 0 );
	buf_idx += 4;
	
	var pal_addr = set_pal(x,y,_pal);
	ppu.put( 0x23c0 + pal_addr, &pal[pal_addr], 1, 0 );
}

function draw_screen():void
{
	var ax:int, ay:int;
	for(ax, 0, 16){
		for(ay, 0, 15){
			var cell:int = data[ay*16+ax];
			put_in_lock(ax, ay, cell);
		}
	}
}

function fetch_area(area:int):void
{
	cur_area = area;
	fs.copy( data_buf, fs.TILE_BASE+area );
	var len = rle.unpack( data, data_buf );
	if( len != 16*15 ){ asm( ".byte 2" ); } // length check

	len = fs.copy( enemy, fs.ENEMY_BASE+area );
	enemy_num = len/6;

	// パレット、タイルデータの切り替え
	var pal = fs.AREA_TYPES[area];
	if( pal ){
		fs.copy( &tile_pal[32], fs.TILE_PAL_BASE+pal );
		mem.copy( &tile_type[32], &TILE_TYPE[pal*32], 32 );
		mem.copy( &bg.pallet[4], &fs.PAL_SET[(pal-1)*16+4], 12 );
		mmc3.set_cbank(1, CBANK_BG+(pal-1)*2);
	}
	
}

public function scroll(dir:int):void
{
	var old_area = cur_area;
	var new_area = cur_area + DIR_VY[dir]*fs.MAP_WIDTH + DIR_VX[dir];

	before_scroll(new_area, old_area);
	
	switch(dir){
	case DIR_UP:
		scroll_up();
	case DIR_DOWN:
		scroll_down();
	case DIR_LEFT:
		scroll_left();
	case DIR_RIGHT:
		scroll_right();
	}
	
	after_scroll(new_area, old_area);
}

function before_scroll(new_area:int, old_area:int):void
{
	if( !my.items[fs.ITEM_ID_LAMP] && new_area == 3*fs.MAP_WIDTH+8 ){ light_down(); }
	if( !my.items[fs.ITEM_ID_LAMP] && new_area == 1*fs.MAP_WIDTH+4 ){ light_down(); }
}

function after_scroll(new_area:int, old_area:int):void
{
	if( !my.items[fs.ITEM_ID_LAMP] && old_area == 3*fs.MAP_WIDTH+8 ){ light_up(); }
	if( !my.items[fs.ITEM_ID_LAMP] && old_area == 1*fs.MAP_WIDTH+4 ){ light_up(); }
}

const VRAM_PALLET = 0x3f00;

function pal_down(pal:int*, size:int, pow:int):void
{
	var i:int;
	var n = pow*16;
	for( i, 0, size ){
		var c = pal[i];
		if( c != 0x0d ){
			c = c - n;
			if( c > 64 ){ c = 0x0d; }
			pal[i] = c;
		}
	}
}

function light_down():void
{
	var buf = ppu.alloc(16);
	var i:int;
	for( i, 0, 4 ){
		mem.copy( buf, pallet, 16 );
		if( i >= 1 ){
			pal_down(buf, 4, 1);
			pal_down(buf+4, 12, i+1);
		}else{
			pal_down(buf, 16, i+1);
		}
		ppu.put( VRAM_PALLET, buf, 16, 0 );
		var j:int;
		for( j, 0, 4 ){	ppu.wait_vsync_with_flag(2); }
	}
}

function light_up():void
{
	var buf = ppu.alloc(16);
	var i:int;
	for( i, 0, 4 ){
		mem.copy( buf, pallet, 16 );
		if( i < 1 ){
			pal_down(buf, 4, 1);
			pal_down(buf+4, 12, 3-i);
		}else{
			pal_down(buf, 16, 3-i);
		}
		ppu.put( VRAM_PALLET, buf, 16, 0 );
		var j:int;
		for( j, 0, 4 ){	ppu.wait_vsync_with_flag(2); }
	}
}

function scroll_left():void
{
	var x = 15;
	cur_area -= 1;
	fetch_area(cur_area);
	ppu.put( VRAM_PALETTE+4, &bg.pallet[4], 12, 0 );
	ppu.wait_vsync_with_flag(2);
	mmc3.MIRROR = 1; // horizontal
	loop(){
		draw_map_vertical(x);

		var i:int;
		for(i, 0, 2){
			my.x += (116+GIFF_TABLE[x])/16;
			my.draw();
			ppu.scroll1 = x*16+8-i*8;
			if( i == 1 ){ ppu.put( 0x23c0 + x/2, &pal[x/2], 8, ppu.ATTRIBUTE ); }
			ppu.wait_vsync();
		}
		
		if( x == 0 ){ break; }
		x -= 1;
	}
}

function scroll_right():void
{
	var x = 0;
	cur_area += 1;
	fetch_area(cur_area);
	ppu.put( VRAM_PALETTE+4, &bg.pallet[4], 12, 0 );
	ppu.wait_vsync_with_flag(2);
	mmc3.MIRROR = 1; // horizontal
	loop(){
		draw_map_vertical(x);

		var i:int;
		for(i, 0, 2){
			my.x -= (116+GIFF_TABLE[x])/16;
			my.draw();
			ppu.scroll1 = x*16+i*8+8;
			if( i == 1 ){ ppu.put( 0x23c0 + x/2, &pal[x/2], 8, ppu.ATTRIBUTE ); }
			ppu.wait_vsync();
		}
		
		if( x == 15 ){ break; }
		x += 1;
	}
}

function scroll_up():void
{
	var y = 14;
	cur_area -= fs.MAP_WIDTH;
	fetch_area(cur_area);
	ppu.put( VRAM_PALETTE+4, &bg.pallet[4], 12, 0 );
	ppu.wait_vsync_with_flag(2);
	mmc3.MIRROR = 0; // vertical
	loop(){
		draw_map_horizontal(y);

		var i:int;
		for(i, 0, 2){
			my.y += (116+GIFF_TABLE[y])/16;
			my.draw();
			ppu.scroll2 = y*16+8-i*8;
			if( ppu.scroll2 == 240 ){ ppu.scroll2 = 0; }
			ppu.wait_vsync();
		}
		
		if( y == 0 ){ break; }
		y -= 1;
	}
}

function scroll_down():void
{
	var y = 0;
	cur_area += fs.MAP_WIDTH;
	fetch_area(cur_area);
	ppu.put( VRAM_PALETTE+4, &bg.pallet[4], 12, 0 );
	ppu.wait_vsync_with_flag(2);
	mmc3.MIRROR = 0; // vertical
	loop(){
		draw_map_horizontal(y);

		var i:int;
		for(i, 0, 2){
			my.y -= (116+GIFF_TABLE[y])/16;
			my.draw();
			ppu.scroll2 = y*16+i*8+8;
			if( ppu.scroll2 == 240 ){ ppu.scroll2 = 0; }
			ppu.wait_vsync();
		}
		
		if( y == 14 ){ break; }
		y += 1;
	}
}

function put_in_lock(x:int, y:int, n:int):void
{
	var y16:int16 = y;
	var addr:int16 = 0x2000 + y16*64 + x*2;
	var ni = n * 4;
	buf[0] = ni;
	buf[1] = ni+2;
	buf[2] = ni+1;
	buf[3] = ni+3;
	ppu.put_in_lock( addr, buf, 2 );
	ppu.put_in_lock( addr+32, &buf[2], 2 );

	var pal_addr = set_pal(x,y,tile_pal[n]);
	ppu.put_in_lock( 0x23c0 + pal_addr, &pal[pal_addr], 1 );
}

function draw_map_vertical(x:int):void
{
	var addr:int16 = 0x2000 + x*2;
	var y:int;
	for( y, 0, 15 ){
		var n = data[y*16+x];
		var ni = n * 4;
		var idx = buf_idx+y*2;
		buf[idx] = ni;
		buf[idx+1] = ni+1;
		buf[idx+30] = ni+2;
		buf[idx+31] = ni+3;
		set_pal(x,y,tile_pal[n]);
	}
	ppu.put( addr, &buf[buf_idx], 30, ppu.VERTICAL);
	ppu.put( addr+1, &buf[buf_idx+30], 30, ppu.VERTICAL);
	// gr_add( 0x23c0 + x/2, &bg_pal[x/2], 8, PPU_ATTRIBUTE ); // 間に合わないので外に出す
	buf_idx += 60;
}

function draw_map_horizontal(y:int):void
{
	var y16:int16 = y;
	var addr:int16 = 0x2000 + y16*64;
	var x:int;
	for( x, 0, 16 ){
		var n = data[y*16+x];
		var ni = n * 4;
		var idx = buf_idx+x*2;
		buf[idx] = ni;
		buf[idx+1] = ni+2;
		buf[idx+32] = ni+1;
		buf[idx+33] = ni+3;
		set_pal(x,y,tile_pal[n]);
	}
	ppu.put( addr, &buf[buf_idx], 64, ppu.HORIZONTAL);
	var pal_addr = (y/2)*8;
	ppu.put( 0x23c0 + pal_addr, &pal[pal_addr], 8, ppu.HORIZONTAL );
	buf_idx += 64;
}

